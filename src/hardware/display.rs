#![allow(dead_code)]
use super::{
    pins::{LcdLed, LcdOn},
    LcdHardware,
};
use alloc::string::String;
use embedded_hal::digital::v2::OutputPin;
use lcd::*;

pub struct Lcd {
    lcd: Display<LcdHardware>,
    on: LcdOn,
    led: LcdLed,
    not_active: bool,
    loaded_chars: [bool; 8], // Отслеживаем загруженные пользовательские символы
}

impl Lcd {
    pub fn new(hd44780: LcdHardware, on: LcdOn, led: LcdLed) -> Self {
        Self {
            lcd: Display::new(hd44780),
            on,
            led,
            not_active: true,
            loaded_chars: [false; 8],
        }
    }

    pub fn init(&mut self) -> bool {
        let ret = self.not_active;
        if self.not_active {
            defmt::trace!("lcd init");
            self.not_active = false;
            self.led.set_high().unwrap();
            self.on.set_low().unwrap();
            self.lcd.init(FunctionLine::Line2, FunctionDots::Dots5x8);
            self.lcd.display(
                DisplayMode::DisplayOn,
                DisplayCursor::CursorOff,
                DisplayBlink::BlinkOff,
            );
            self.lcd
                .entry_mode(EntryModeDirection::EntryRight, EntryModeShift::NoShift);
            self.lcd
                .upload_character(0u8, [0x1f, 0x0, 0xe, 0x1, 0xf, 0x11, 0xf, 0x0]);
        }
        ret
    }

    pub fn off(&mut self) {
        defmt::trace!("lcd off");
        self.on.set_high().unwrap();
        self.not_active = true;
    }

    pub fn led(&mut self, on: bool) {
        if on {
            self.led_on();
        } else {
            self.led_off();
        }
    }

    pub fn led_on(&mut self) {
        self.led.set_low().unwrap();
    }

    pub fn led_off(&mut self) {
        self.led.set_high().unwrap();
    }

    // Динамическая загрузка пользовательского символа
    fn load_custom_char(&mut self, pattern: [u8; 8]) -> Option<u8> {
        // Ищем свободный слот
        for i in 0..8 {
            if !self.loaded_chars[i] {
                self.lcd.upload_character(i as u8, pattern);
                self.loaded_chars[i] = true;
                defmt::trace!("Loaded custom char in slot {} for Russian font", i);
                return Some(i as u8);
            }
        }
        // Все слоты заняты
        defmt::warn!("No free slots for custom character");
        None
    }

    // Сброс всех загруженных пользовательских символов
    pub fn reset_custom_chars(&mut self) {
        self.loaded_chars = [false; 8];
        defmt::trace!("Reset custom characters");
    }

    // Получить количество загруженных пользовательских символов
    pub fn get_loaded_chars_count(&self) -> usize {
        self.loaded_chars.iter().filter(|&&x| x).count()
    }

    // Проверить, загружен ли конкретный символ
    pub fn is_char_loaded(&self, char_code: u8) -> bool {
        if char_code < 8 {
            self.loaded_chars[char_code as usize]
        } else {
            false
        }
    }

    // Clear the display and reset custom characters
    pub fn clear(&mut self) {
        self.lcd.clear();
        self.reset_custom_chars();
    }

    // Set cursor position
    pub fn set_position(&mut self, col: u8, row: u8) {
        self.lcd.position(col, row);
    }

    // Предварительная загрузка всех русских символов
    pub fn preload_russian_chars(&mut self) {
        let russian_chars = [
            // Заглавные буквы
            ('А', [0x1f, 0x11, 0x11, 0x11, 0x11, 0x11, 0x1f, 0x00]),
            ('Б', [0x1f, 0x11, 0x11, 0x1f, 0x11, 0x11, 0x1f, 0x00]),
            ('В', [0x1f, 0x11, 0x11, 0x1f, 0x11, 0x11, 0x1f, 0x00]),
            ('Г', [0x1f, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x00]),
            ('Д', [0x0f, 0x09, 0x09, 0x09, 0x09, 0x1f, 0x11, 0x00]),
            ('Е', [0x1f, 0x10, 0x10, 0x1f, 0x10, 0x10, 0x1f, 0x00]),
            ('Ж', [0x11, 0x11, 0x0a, 0x04, 0x0a, 0x11, 0x11, 0x00]),
            ('З', [0x1f, 0x01, 0x01, 0x0f, 0x01, 0x01, 0x1f, 0x00]),
            ('И', [0x11, 0x13, 0x15, 0x19, 0x11, 0x11, 0x11, 0x00]),
            ('Й', [0x04, 0x11, 0x13, 0x15, 0x19, 0x11, 0x11, 0x00]),
            ('К', [0x11, 0x12, 0x14, 0x18, 0x14, 0x12, 0x11, 0x00]),
            ('Л', [0x0e, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x00]),
            ('М', [0x11, 0x1b, 0x15, 0x11, 0x11, 0x11, 0x11, 0x00]),
            ('Н', [0x11, 0x11, 0x11, 0x1f, 0x11, 0x11, 0x11, 0x00]),
            ('О', [0x0e, 0x11, 0x11, 0x11, 0x11, 0x11, 0x0e, 0x00]),
            ('П', [0x1f, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x00]),
            ('Р', [0x1f, 0x11, 0x11, 0x1f, 0x10, 0x10, 0x10, 0x00]),
            ('С', [0x0e, 0x11, 0x10, 0x10, 0x10, 0x11, 0x0e, 0x00]),
            ('Т', [0x1f, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x00]),
            ('У', [0x11, 0x11, 0x11, 0x0a, 0x04, 0x04, 0x04, 0x00]),
            ('Ф', [0x0e, 0x15, 0x15, 0x15, 0x0e, 0x04, 0x04, 0x00]),
            ('Х', [0x11, 0x11, 0x0a, 0x04, 0x0a, 0x11, 0x11, 0x00]),
            ('Ц', [0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x1f, 0x01]),
            ('Ч', [0x11, 0x11, 0x11, 0x0f, 0x01, 0x01, 0x01, 0x00]),
            ('Ш', [0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x1f, 0x00]),
            ('Щ', [0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x1f, 0x01]),
            ('Ъ', [0x18, 0x08, 0x08, 0x0f, 0x09, 0x09, 0x0f, 0x00]),
            ('Ы', [0x11, 0x11, 0x11, 0x17, 0x19, 0x19, 0x17, 0x00]),
            ('Ь', [0x10, 0x10, 0x10, 0x1f, 0x11, 0x11, 0x1f, 0x00]),
            ('Э', [0x1f, 0x01, 0x01, 0x0f, 0x01, 0x01, 0x1f, 0x00]),
            ('Ю', [0x17, 0x19, 0x19, 0x19, 0x19, 0x19, 0x17, 0x00]),
            ('Я', [0x0f, 0x11, 0x11, 0x0f, 0x05, 0x09, 0x11, 0x00]),
            // Строчные буквы
            ('а', [0x00, 0x00, 0x0e, 0x01, 0x0f, 0x11, 0x0f, 0x00]),
            ('б', [0x01, 0x01, 0x0f, 0x11, 0x11, 0x11, 0x0f, 0x00]),
            ('в', [0x00, 0x00, 0x17, 0x19, 0x17, 0x19, 0x17, 0x00]),
            ('г', [0x00, 0x00, 0x1e, 0x10, 0x10, 0x10, 0x10, 0x00]),
            ('д', [0x00, 0x00, 0x0e, 0x11, 0x11, 0x0f, 0x01, 0x1f]),
            ('е', [0x00, 0x00, 0x0e, 0x11, 0x1f, 0x10, 0x0e, 0x00]),
            ('ж', [0x00, 0x00, 0x15, 0x15, 0x0e, 0x15, 0x15, 0x00]),
            ('з', [0x00, 0x00, 0x0e, 0x01, 0x06, 0x01, 0x0e, 0x00]),
            ('и', [0x00, 0x00, 0x11, 0x13, 0x15, 0x19, 0x11, 0x00]),
            ('й', [0x04, 0x00, 0x11, 0x13, 0x15, 0x19, 0x11, 0x00]),
            ('к', [0x00, 0x00, 0x12, 0x14, 0x18, 0x14, 0x12, 0x00]),
            ('л', [0x00, 0x00, 0x07, 0x09, 0x09, 0x09, 0x09, 0x00]),
            ('м', [0x00, 0x00, 0x11, 0x1b, 0x15, 0x11, 0x11, 0x00]),
            ('н', [0x00, 0x00, 0x11, 0x11, 0x1f, 0x11, 0x11, 0x00]),
            ('о', [0x00, 0x00, 0x0e, 0x11, 0x11, 0x11, 0x0e, 0x00]),
            ('п', [0x00, 0x00, 0x1f, 0x11, 0x11, 0x11, 0x11, 0x00]),
            ('р', [0x00, 0x00, 0x17, 0x19, 0x19, 0x17, 0x10, 0x10]),
            ('с', [0x00, 0x00, 0x0e, 0x10, 0x10, 0x10, 0x0e, 0x00]),
            ('т', [0x00, 0x00, 0x1f, 0x04, 0x04, 0x04, 0x04, 0x00]),
            ('у', [0x00, 0x00, 0x11, 0x11, 0x11, 0x0f, 0x01, 0x0e]),
            ('ф', [0x00, 0x04, 0x0e, 0x15, 0x15, 0x0e, 0x04, 0x00]),
            ('х', [0x00, 0x00, 0x11, 0x0a, 0x04, 0x0a, 0x11, 0x00]),
            ('ц', [0x00, 0x00, 0x11, 0x11, 0x11, 0x11, 0x1f, 0x01]),
            ('ч', [0x00, 0x00, 0x11, 0x11, 0x11, 0x0f, 0x01, 0x01]),
            ('ш', [0x00, 0x00, 0x15, 0x15, 0x15, 0x15, 0x1f, 0x00]),
            ('щ', [0x00, 0x00, 0x15, 0x15, 0x15, 0x15, 0x1f, 0x01]),
            ('ъ', [0x00, 0x00, 0x18, 0x08, 0x0f, 0x09, 0x0f, 0x00]),
            ('ы', [0x00, 0x00, 0x11, 0x11, 0x17, 0x19, 0x17, 0x00]),
            ('ь', [0x00, 0x00, 0x10, 0x10, 0x1f, 0x11, 0x1f, 0x00]),
            ('э', [0x00, 0x00, 0x0e, 0x01, 0x0f, 0x01, 0x0e, 0x00]),
            ('ю', [0x00, 0x00, 0x17, 0x19, 0x19, 0x19, 0x17, 0x00]),
            ('я', [0x00, 0x00, 0x0f, 0x11, 0x0f, 0x05, 0x09, 0x00]),
            // Дополнительные символы
            ('ё', [0x0a, 0x00, 0x0e, 0x11, 0x1f, 0x10, 0x0e, 0x00]),
            ('Ё', [0x0a, 0x00, 0x0e, 0x11, 0x1f, 0x10, 0x0e, 0x00]),
        ];
        let mut loaded_count = 0;

        for (_, pattern) in &russian_chars {
            if self.load_custom_char(*pattern).is_some() {
                loaded_count += 1;
            }
        }

        defmt::info!("Preloaded {} Russian characters", loaded_count);
    }

    fn convert_char(&mut self, c: char) -> u8 {
        match c {
            //'0' => b'O',
            //'\0'..='\u{ff}' => c as u8,
            // Заглавные русские буквы
            'А' => self
                .load_custom_char([0x1f, 0x11, 0x11, 0x11, 0x11, 0x11, 0x1f, 0x00])
                .unwrap_or(b'A'),
            'Б' => self
                .load_custom_char([0x1f, 0x11, 0x11, 0x1f, 0x11, 0x11, 0x1f, 0x00])
                .unwrap_or(b'B'),
            'В' => self
                .load_custom_char([0x1f, 0x11, 0x11, 0x1f, 0x11, 0x11, 0x1f, 0x00])
                .unwrap_or(b'B'),
            'Г' => self
                .load_custom_char([0x1f, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x00])
                .unwrap_or(b'L'),
            'Д' => self
                .load_custom_char([0x0f, 0x09, 0x09, 0x09, 0x09, 0x1f, 0x11, 0x00])
                .unwrap_or(b'U'),
            'Е' => self
                .load_custom_char([0x1f, 0x10, 0x10, 0x1f, 0x10, 0x10, 0x1f, 0x00])
                .unwrap_or(b'E'),
            'Ж' => self
                .load_custom_char([0x11, 0x11, 0x0a, 0x04, 0x0a, 0x11, 0x11, 0x00])
                .unwrap_or(b'X'),
            'З' => self
                .load_custom_char([0x1f, 0x01, 0x01, 0x0f, 0x01, 0x01, 0x1f, 0x00])
                .unwrap_or(b'3'),
            'И' => self
                .load_custom_char([0x11, 0x13, 0x15, 0x19, 0x11, 0x11, 0x11, 0x00])
                .unwrap_or(b'I'),
            'Й' => self
                .load_custom_char([0x04, 0x11, 0x13, 0x15, 0x19, 0x11, 0x11, 0x00])
                .unwrap_or(b'I'),
            'К' => self
                .load_custom_char([0x11, 0x12, 0x14, 0x18, 0x14, 0x12, 0x11, 0x00])
                .unwrap_or(b'K'),
            'Л' => self
                .load_custom_char([0x0e, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x00])
                .unwrap_or(b'V'),
            'М' => self
                .load_custom_char([0x11, 0x1b, 0x15, 0x11, 0x11, 0x11, 0x11, 0x00])
                .unwrap_or(b'M'),
            'Н' => self
                .load_custom_char([0x11, 0x11, 0x11, 0x1f, 0x11, 0x11, 0x11, 0x00])
                .unwrap_or(b'H'),
            'О' => self
                .load_custom_char([0x0e, 0x11, 0x11, 0x11, 0x11, 0x11, 0x0e, 0x00])
                .unwrap_or(b'O'),
            'П' => self
                .load_custom_char([0x1f, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x00])
                .unwrap_or(b'U'),
            'Р' => self
                .load_custom_char([0x1f, 0x11, 0x11, 0x1f, 0x10, 0x10, 0x10, 0x00])
                .unwrap_or(b'P'),
            'С' => self
                .load_custom_char([0x0e, 0x11, 0x10, 0x10, 0x10, 0x11, 0x0e, 0x00])
                .unwrap_or(b'C'),
            'Т' => self
                .load_custom_char([0x1f, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x00])
                .unwrap_or(b'T'),
            'У' => self
                .load_custom_char([0x11, 0x11, 0x11, 0x0a, 0x04, 0x04, 0x04, 0x00])
                .unwrap_or(b'Y'),
            'Ф' => self
                .load_custom_char([0x0e, 0x15, 0x15, 0x15, 0x0e, 0x04, 0x04, 0x00])
                .unwrap_or(b'F'),
            'Х' => self
                .load_custom_char([0x11, 0x11, 0x0a, 0x04, 0x0a, 0x11, 0x11, 0x00])
                .unwrap_or(b'X'),
            'Ц' => self
                .load_custom_char([0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x1f, 0x01])
                .unwrap_or(b'U'),
            'Ч' => self
                .load_custom_char([0x11, 0x11, 0x11, 0x0f, 0x01, 0x01, 0x01, 0x00])
                .unwrap_or(b'4'),
            'Ш' => self
                .load_custom_char([0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x1f, 0x00])
                .unwrap_or(b'W'),
            'Щ' => self
                .load_custom_char([0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x1f, 0x01])
                .unwrap_or(b'W'),
            'Ъ' => self
                .load_custom_char([0x18, 0x08, 0x08, 0x0f, 0x09, 0x09, 0x0f, 0x00])
                .unwrap_or(b'b'),
            'Ы' => self
                .load_custom_char([0x11, 0x11, 0x11, 0x17, 0x19, 0x19, 0x17, 0x00])
                .unwrap_or(b'B'),
            'Ь' => self
                .load_custom_char([0x10, 0x10, 0x10, 0x1f, 0x11, 0x11, 0x1f, 0x00])
                .unwrap_or(b'b'),
            'Э' => self
                .load_custom_char([0x1f, 0x01, 0x01, 0x0f, 0x01, 0x01, 0x1f, 0x00])
                .unwrap_or(b'E'),
            'Ю' => self
                .load_custom_char([0x17, 0x19, 0x19, 0x19, 0x19, 0x19, 0x17, 0x00])
                .unwrap_or(b'U'),
            'Я' => self
                .load_custom_char([0x0f, 0x11, 0x11, 0x0f, 0x05, 0x09, 0x11, 0x00])
                .unwrap_or(b'R'),
            // Строчные русские буквы
            'а' => self
                .load_custom_char([0x00, 0x00, 0x0e, 0x01, 0x0f, 0x11, 0x0f, 0x00])
                .unwrap_or(b'a'),
            'б' => self
                .load_custom_char([0x01, 0x01, 0x0f, 0x11, 0x11, 0x11, 0x0f, 0x00])
                .unwrap_or(b'6'),
            'в' => self
                .load_custom_char([0x00, 0x00, 0x17, 0x19, 0x17, 0x19, 0x17, 0x00])
                .unwrap_or(b'b'),
            'г' => self
                .load_custom_char([0x00, 0x00, 0x1e, 0x10, 0x10, 0x10, 0x10, 0x00])
                .unwrap_or(b'r'),
            'д' => self
                .load_custom_char([0x00, 0x00, 0x0e, 0x11, 0x11, 0x0f, 0x01, 0x1f])
                .unwrap_or(b'd'),
            'е' => self
                .load_custom_char([0x00, 0x00, 0x0e, 0x11, 0x1f, 0x10, 0x0e, 0x00])
                .unwrap_or(b'e'),
            'ж' => self
                .load_custom_char([0x00, 0x00, 0x15, 0x15, 0x0e, 0x15, 0x15, 0x00])
                .unwrap_or(b'x'),
            'з' => self
                .load_custom_char([0x00, 0x00, 0x0e, 0x01, 0x06, 0x01, 0x0e, 0x00])
                .unwrap_or(b'3'),
            'и' => self
                .load_custom_char([0x00, 0x00, 0x11, 0x13, 0x15, 0x19, 0x11, 0x00])
                .unwrap_or(b'u'),
            'й' => self
                .load_custom_char([0x04, 0x00, 0x11, 0x13, 0x15, 0x19, 0x11, 0x00])
                .unwrap_or(b'u'),
            'к' => self
                .load_custom_char([0x00, 0x00, 0x12, 0x14, 0x18, 0x14, 0x12, 0x00])
                .unwrap_or(b'k'),
            'л' => self
                .load_custom_char([0x00, 0x00, 0x07, 0x09, 0x09, 0x09, 0x09, 0x00])
                .unwrap_or(b'n'),
            'м' => self
                .load_custom_char([0x00, 0x00, 0x11, 0x1b, 0x15, 0x11, 0x11, 0x00])
                .unwrap_or(b'm'),
            'н' => self
                .load_custom_char([0x00, 0x00, 0x11, 0x11, 0x1f, 0x11, 0x11, 0x00])
                .unwrap_or(b'h'),
            'о' => self
                .load_custom_char([0x00, 0x00, 0x0e, 0x11, 0x11, 0x11, 0x0e, 0x00])
                .unwrap_or(b'o'),
            'п' => self
                .load_custom_char([0x00, 0x00, 0x1f, 0x11, 0x11, 0x11, 0x11, 0x00])
                .unwrap_or(b'n'),
            'р' => self
                .load_custom_char([0x00, 0x00, 0x17, 0x19, 0x19, 0x17, 0x10, 0x10])
                .unwrap_or(b'p'),
            'с' => self
                .load_custom_char([0x00, 0x00, 0x0e, 0x10, 0x10, 0x10, 0x0e, 0x00])
                .unwrap_or(b'c'),
            'т' => self
                .load_custom_char([0x00, 0x00, 0x1f, 0x04, 0x04, 0x04, 0x04, 0x00])
                .unwrap_or(b't'),
            'у' => self
                .load_custom_char([0x00, 0x00, 0x11, 0x11, 0x11, 0x0f, 0x01, 0x0e])
                .unwrap_or(b'y'),
            'ф' => self
                .load_custom_char([0x00, 0x04, 0x0e, 0x15, 0x15, 0x0e, 0x04, 0x00])
                .unwrap_or(b'f'),
            'х' => self
                .load_custom_char([0x00, 0x00, 0x11, 0x0a, 0x04, 0x0a, 0x11, 0x00])
                .unwrap_or(b'x'),
            'ц' => self
                .load_custom_char([0x00, 0x00, 0x11, 0x11, 0x11, 0x11, 0x1f, 0x01])
                .unwrap_or(b'u'),
            'ч' => self
                .load_custom_char([0x00, 0x00, 0x11, 0x11, 0x11, 0x0f, 0x01, 0x01])
                .unwrap_or(b'4'),
            'ш' => self
                .load_custom_char([0x00, 0x00, 0x15, 0x15, 0x15, 0x15, 0x1f, 0x00])
                .unwrap_or(b'w'),
            'щ' => self
                .load_custom_char([0x00, 0x00, 0x15, 0x15, 0x15, 0x15, 0x1f, 0x01])
                .unwrap_or(b'w'),
            'ъ' => self
                .load_custom_char([0x00, 0x00, 0x18, 0x08, 0x0f, 0x09, 0x0f, 0x00])
                .unwrap_or(b'b'),
            'ы' => self
                .load_custom_char([0x00, 0x00, 0x11, 0x11, 0x17, 0x19, 0x17, 0x00])
                .unwrap_or(b'b'),
            'ь' => self
                .load_custom_char([0x00, 0x00, 0x10, 0x10, 0x1f, 0x11, 0x1f, 0x00])
                .unwrap_or(b'b'),
            'э' => self
                .load_custom_char([0x00, 0x00, 0x0e, 0x01, 0x0f, 0x01, 0x0e, 0x00])
                .unwrap_or(b'e'),
            'ю' => self
                .load_custom_char([0x00, 0x00, 0x17, 0x19, 0x19, 0x19, 0x17, 0x00])
                .unwrap_or(b'u'),
            'я' => self
                .load_custom_char([0x00, 0x00, 0x0f, 0x11, 0x0f, 0x05, 0x09, 0x00])
                .unwrap_or(b'r'),
            // Дополнительные символы
            'ё' => self
                .load_custom_char([0x0a, 0x00, 0x0e, 0x11, 0x1f, 0x10, 0x0e, 0x00])
                .unwrap_or(b'e'),
            'Ё' => self
                .load_custom_char([0x0a, 0x00, 0x0e, 0x11, 0x1f, 0x10, 0x0e, 0x00])
                .unwrap_or(b'E'),
            _ => b'\0',
        }
    }
}

impl core::fmt::Write for Lcd {
    fn write_str(&mut self, s: &str) -> core::fmt::Result {
        let mut val = String::new();
        for c in s.chars().enumerate() {
            let ascii = self.convert_char(c.1);
            val.push(ascii as char);
        }
        self.lcd.write_str(val.as_str()).ok();
        Ok(())
    }
}
