#![allow(dead_code)]
use super::{
    pins::{LcdLed, LcdOn},
    LcdHardware,
};
use alloc::string::String;
use embedded_hal::digital::v2::OutputPin;
use lcd::*;

pub struct Lcd {
    lcd: Display<LcdHardware>,
    on: LcdOn,
    led: LcdLed,
    not_active: bool,
    loaded_chars: [bool; 8], // Отслеживаем загруженные пользовательские символы
    cursor_col: u8, // Текущая позиция курсора
    cursor_row: u8,
}

impl Lcd {
    pub fn new(hd44780: LcdHardware, on: LcdOn, led: LcdLed) -> Self {
        Self {
            lcd: Display::new(hd44780),
            on,
            led,
            not_active: true,
            loaded_chars: [false; 8],
            cursor_col: 0,
            cursor_row: 0,
        }
    }

    pub fn init(&mut self) -> bool {
        let ret = self.not_active;
        if self.not_active {
            defmt::trace!("lcd init");
            self.not_active = false;
            self.led.set_high().unwrap();
            self.on.set_low().unwrap();
            self.lcd.init(FunctionLine::Line2, FunctionDots::Dots5x8);
            self.lcd.display(
                DisplayMode::DisplayOn,
                DisplayCursor::CursorOff,
                DisplayBlink::BlinkOff,
            );
            self.lcd
                .entry_mode(EntryModeDirection::EntryRight, EntryModeShift::NoShift);
            //           self.lcd
            //              .upload_character(0u8, [0x1f, 0x0, 0xe, 0x1, 0xf, 0x11, 0xf, 0x0]);
        }
        ret
    }

    pub fn off(&mut self) {
        defmt::trace!("lcd off");
        self.on.set_high().unwrap();
        self.not_active = true;
    }

    pub fn led(&mut self, on: bool) {
        if on {
            self.led_on();
        } else {
            self.led_off();
        }
    }

    pub fn led_on(&mut self) {
        self.led.set_low().unwrap();
    }

    pub fn led_off(&mut self) {
        self.led.set_high().unwrap();
    }

    // Динамическая загрузка пользовательского символа
    fn load_custom_char(&mut self, pattern: [u8; 8]) -> Option<u8> {
        // Ищем свободный слот
        for i in 0..8 {
            if !self.loaded_chars[i] {
                // Сохраняем текущую позицию курсора
                let saved_col = self.cursor_col;
                let saved_row = self.cursor_row;
                
                // Загружаем символ в CGRAM
                self.lcd.upload_character(i as u8, pattern);
                self.loaded_chars[i] = true;
                
                // Важно: после загрузки в CGRAM нужно вернуться к DDRAM
                // Восстанавливаем позицию курсора на LCD
                self.lcd.position(saved_col, saved_row);
                // НЕ изменяем self.cursor_col и self.cursor_row - они уже корректны
                
                defmt::trace!("Loaded custom char in slot {} for Russian font", i);
                return Some(i as u8);
            }
        }
        // Все слоты заняты
        defmt::warn!("No free slots for custom character");
        None
    }

    // Сброс всех загруженных пользовательских символов
    pub fn reset_custom_chars(&mut self) {
        self.loaded_chars = [false; 8];
        defmt::trace!("Reset custom characters");
    }

    // Получить количество загруженных пользовательских символов
    pub fn get_loaded_chars_count(&self) -> usize {
        self.loaded_chars.iter().filter(|&&x| x).count()
    }

    // Проверить, загружен ли конкретный символ
    pub fn is_char_loaded(&self, char_code: u8) -> bool {
        if char_code < 8 {
            self.loaded_chars[char_code as usize]
        } else {
            false
        }
    }

    // Clear the display and reset custom characters
    pub fn clear(&mut self) {
        self.lcd.clear();
        self.reset_custom_chars();
        self.cursor_col = 0;
        self.cursor_row = 0;
    }

    // Set cursor position
    pub fn set_position(&mut self, col: u8, row: u8) {
        self.lcd.position(col, row);
        self.cursor_col = col;
        self.cursor_row = row;
    }

    // Предварительная загрузка всех русских символов
    pub fn preload_russian_chars(&mut self) {
        let russian_chars = [
            // Заглавные буквы
            ('А', [0x1f, 0x11, 0x11, 0x11, 0x11, 0x11, 0x1f, 0x00]),
            ('Б', [0x1f, 0x11, 0x11, 0x1f, 0x11, 0x11, 0x1f, 0x00]),
            ('В', [0x1f, 0x11, 0x11, 0x1f, 0x11, 0x11, 0x1f, 0x00]),
            ('Г', [0x1f, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x00]),
            ('Д', [0x0f, 0x09, 0x09, 0x09, 0x09, 0x1f, 0x11, 0x00]),
            ('Е', [0x1f, 0x10, 0x10, 0x1f, 0x10, 0x10, 0x1f, 0x00]),
            ('Ж', [0x11, 0x11, 0x0a, 0x04, 0x0a, 0x11, 0x11, 0x00]),
            ('З', [0x1f, 0x01, 0x01, 0x0f, 0x01, 0x01, 0x1f, 0x00]),
            ('И', [0x11, 0x13, 0x15, 0x19, 0x11, 0x11, 0x11, 0x00]),
            ('Й', [0x04, 0x11, 0x13, 0x15, 0x19, 0x11, 0x11, 0x00]),
            ('К', [0x11, 0x12, 0x14, 0x18, 0x14, 0x12, 0x11, 0x00]),
            ('Л', [0x0e, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x00]),
            ('М', [0x11, 0x1b, 0x15, 0x11, 0x11, 0x11, 0x11, 0x00]),
            ('Н', [0x11, 0x11, 0x11, 0x1f, 0x11, 0x11, 0x11, 0x00]),
            ('О', [0x0e, 0x11, 0x11, 0x11, 0x11, 0x11, 0x0e, 0x00]),
            ('П', [0x1f, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x00]),
            ('Р', [0x1f, 0x11, 0x11, 0x1f, 0x10, 0x10, 0x10, 0x00]),
            ('С', [0x0e, 0x11, 0x10, 0x10, 0x10, 0x11, 0x0e, 0x00]),
            ('Т', [0x1f, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x00]),
            ('У', [0x11, 0x11, 0x11, 0x0a, 0x04, 0x04, 0x04, 0x00]),
            ('Ф', [0x0e, 0x15, 0x15, 0x15, 0x0e, 0x04, 0x04, 0x00]),
            ('Х', [0x11, 0x11, 0x0a, 0x04, 0x0a, 0x11, 0x11, 0x00]),
            ('Ц', [0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x1f, 0x01]),
            ('Ч', [0x11, 0x11, 0x11, 0x0f, 0x01, 0x01, 0x01, 0x00]),
            ('Ш', [0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x1f, 0x00]),
            ('Щ', [0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x1f, 0x01]),
            ('Ъ', [0x18, 0x08, 0x08, 0x0f, 0x09, 0x09, 0x0f, 0x00]),
            ('Ы', [0x11, 0x11, 0x11, 0x17, 0x19, 0x19, 0x17, 0x00]),
            ('Ь', [0x10, 0x10, 0x10, 0x1f, 0x11, 0x11, 0x1f, 0x00]),
            ('Э', [0x1f, 0x01, 0x01, 0x0f, 0x01, 0x01, 0x1f, 0x00]),
            ('Ю', [0x17, 0x19, 0x19, 0x19, 0x19, 0x19, 0x17, 0x00]),
            ('Я', [0x0f, 0x11, 0x11, 0x0f, 0x05, 0x09, 0x11, 0x00]),
            // Строчные буквы
            ('а', [0x00, 0x00, 0x0e, 0x01, 0x0f, 0x11, 0x0f, 0x00]),
            ('б', [0x01, 0x01, 0x0f, 0x11, 0x11, 0x11, 0x0f, 0x00]),
            ('в', [0x00, 0x00, 0x17, 0x19, 0x17, 0x19, 0x17, 0x00]),
            ('г', [0x00, 0x00, 0x1e, 0x10, 0x10, 0x10, 0x10, 0x00]),
            ('д', [0x00, 0x00, 0x0e, 0x11, 0x11, 0x0f, 0x01, 0x1f]),
            ('е', [0x00, 0x00, 0x0e, 0x11, 0x1f, 0x10, 0x0e, 0x00]),
            ('ж', [0x00, 0x00, 0x15, 0x15, 0x0e, 0x15, 0x15, 0x00]),
            ('з', [0x00, 0x00, 0x0e, 0x01, 0x06, 0x01, 0x0e, 0x00]),
            ('и', [0x00, 0x00, 0x11, 0x13, 0x15, 0x19, 0x11, 0x00]),
            ('й', [0x04, 0x00, 0x11, 0x13, 0x15, 0x19, 0x11, 0x00]),
            ('к', [0x00, 0x00, 0x12, 0x14, 0x18, 0x14, 0x12, 0x00]),
            ('л', [0x00, 0x00, 0x07, 0x09, 0x09, 0x09, 0x09, 0x00]),
            ('м', [0x00, 0x00, 0x11, 0x1b, 0x15, 0x11, 0x11, 0x00]),
            ('н', [0x00, 0x00, 0x11, 0x11, 0x1f, 0x11, 0x11, 0x00]),
            ('о', [0x00, 0x00, 0x0e, 0x11, 0x11, 0x11, 0x0e, 0x00]),
            ('п', [0x00, 0x00, 0x1f, 0x11, 0x11, 0x11, 0x11, 0x00]),
            ('р', [0x00, 0x00, 0x17, 0x19, 0x19, 0x17, 0x10, 0x10]),
            ('с', [0x00, 0x00, 0x0e, 0x10, 0x10, 0x10, 0x0e, 0x00]),
            ('т', [0x00, 0x00, 0x1f, 0x04, 0x04, 0x04, 0x04, 0x00]),
            ('у', [0x00, 0x00, 0x11, 0x11, 0x11, 0x0f, 0x01, 0x0e]),
            ('ф', [0x00, 0x04, 0x0e, 0x15, 0x15, 0x0e, 0x04, 0x00]),
            ('х', [0x00, 0x00, 0x11, 0x0a, 0x04, 0x0a, 0x11, 0x00]),
            ('ц', [0x00, 0x00, 0x11, 0x11, 0x11, 0x11, 0x1f, 0x01]),
            ('ч', [0x00, 0x00, 0x11, 0x11, 0x11, 0x0f, 0x01, 0x01]),
            ('ш', [0x00, 0x00, 0x15, 0x15, 0x15, 0x15, 0x1f, 0x00]),
            ('щ', [0x00, 0x00, 0x15, 0x15, 0x15, 0x15, 0x1f, 0x01]),
            ('ъ', [0x00, 0x00, 0x18, 0x08, 0x0f, 0x09, 0x0f, 0x00]),
            ('ы', [0x00, 0x00, 0x11, 0x11, 0x17, 0x19, 0x17, 0x00]),
            ('ь', [0x00, 0x00, 0x10, 0x10, 0x1f, 0x11, 0x1f, 0x00]),
            ('э', [0x00, 0x00, 0x0e, 0x01, 0x0f, 0x01, 0x0e, 0x00]),
            ('ю', [0x00, 0x00, 0x17, 0x19, 0x19, 0x19, 0x17, 0x00]),
            ('я', [0x00, 0x00, 0x0f, 0x11, 0x0f, 0x05, 0x09, 0x00]),
            // Дополнительные символы
            ('ё', [0x0a, 0x00, 0x0e, 0x11, 0x1f, 0x10, 0x0e, 0x00]),
            ('Ё', [0x0a, 0x00, 0x0e, 0x11, 0x1f, 0x10, 0x0e, 0x00]),
        ];
        let mut loaded_count = 0;

        for (_, pattern) in &russian_chars {
            if self.load_custom_char(*pattern).is_some() {
                loaded_count += 1;
            }
        }

        defmt::info!("Preloaded {} Russian characters", loaded_count);
    }

    fn convert_char(&mut self, c: char) -> u8 {
        match c {
            //'0' => b'O',
            //'\0'..='\u{ff}' => c as u8,
            // Заглавные русские буквы
            'А' => b'A', // Выглядит идентично латинской A
            'Б' => self
                .load_custom_char([0x1f, 0x10, 0x10, 0x1e, 0x11, 0x11, 0x1e, 0x00])
                .unwrap_or(b'B'),
            'В' => b'B', // Выглядит идентично латинской B
            'Г' => self
                .load_custom_char([0x1f, 0x11, 0x10, 0x10, 0x10, 0x10, 0x10, 0x00])
                .unwrap_or(b'L'),
            'Д' => self
                .load_custom_char([0x06, 0x0a, 0x0a, 0x0a, 0x0a, 0x1f, 0x11, 0x00])
                .unwrap_or(b'U'),
            'Е' => b'E', // Выглядит идентично латинской E
            'Ж' => self
                .load_custom_char([0x15, 0x15, 0x0e, 0x04, 0x0e, 0x15, 0x15, 0x00])
                .unwrap_or(b'X'),
            'З' => self
                .load_custom_char([0x0e, 0x11, 0x01, 0x06, 0x01, 0x11, 0x0e, 0x00])
                .unwrap_or(b'3'),
            'И' => self
                .load_custom_char([0x11, 0x11, 0x13, 0x15, 0x19, 0x11, 0x11, 0x00])
                .unwrap_or(b'I'),
            'Й' => self
                .load_custom_char([0x0a, 0x11, 0x13, 0x15, 0x19, 0x11, 0x11, 0x00])
                .unwrap_or(b'I'),
            'К' => b'K', // Выглядит идентично латинской K
            'Л' => self
                .load_custom_char([0x0f, 0x09, 0x09, 0x09, 0x09, 0x11, 0x11, 0x00])
                .unwrap_or(b'V'),
            'М' => b'M', // Выглядит идентично латинской M
            'Н' => self
                .load_custom_char([0x11, 0x11, 0x11, 0x1f, 0x11, 0x11, 0x11, 0x00])
                .unwrap_or(b'H'),
            'О' => b'O', // Выглядит идентично латинской O
            'П' => self
                .load_custom_char([0x1f, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x00])
                .unwrap_or(b'U'),
            'Р' => b'P', // Выглядит идентично латинской P
            'С' => b'C', // Выглядит идентично латинской C
            'Т' => b'T', // Выглядит идентично латинской T
            'У' => self
                .load_custom_char([0x11, 0x11, 0x11, 0x0f, 0x01, 0x02, 0x1c, 0x00])
                .unwrap_or(b'Y'),
            'Ф' => self
                .load_custom_char([0x04, 0x0e, 0x15, 0x15, 0x15, 0x0e, 0x04, 0x00])
                .unwrap_or(b'F'),
            'Х' => b'X', // Выглядит идентично латинской X
            'Ц' => self
                .load_custom_char([0x11, 0x11, 0x11, 0x11, 0x11, 0x1f, 0x1f, 0x01])
                .unwrap_or(b'U'),
            'Ч' => self
                .load_custom_char([0x11, 0x11, 0x11, 0x0f, 0x0f, 0x01, 0x01, 0x00])
                .unwrap_or(b'4'),
            'Ш' => self
                .load_custom_char([0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x1f, 0x00])
                .unwrap_or(b'W'),
            'Щ' => self
                .load_custom_char([0x15, 0x15, 0x15, 0x15, 0x15, 0x1f, 0x1f, 0x01])
                .unwrap_or(b'W'),
            'Ъ' => self
                .load_custom_char([0x1c, 0x04, 0x04, 0x0e, 0x05, 0x05, 0x0e, 0x00])
                .unwrap_or(b'b'),
            'Ы' => self
                .load_custom_char([0x11, 0x11, 0x11, 0x1f, 0x19, 0x19, 0x1f, 0x00])
                .unwrap_or(b'B'),
            'Ь' => self
                .load_custom_char([0x10, 0x10, 0x10, 0x1e, 0x11, 0x11, 0x1e, 0x00])
                .unwrap_or(b'b'),
            'Э' => self
                .load_custom_char([0x0e, 0x11, 0x01, 0x07, 0x01, 0x11, 0x0e, 0x00])
                .unwrap_or(b'E'),
            'Ю' => self
                .load_custom_char([0x12, 0x15, 0x15, 0x1d, 0x15, 0x15, 0x12, 0x00])
                .unwrap_or(b'U'),
            'Я' => self
                .load_custom_char([0x0f, 0x11, 0x11, 0x0f, 0x09, 0x09, 0x11, 0x00])
                .unwrap_or(b'R'),
            // Строчные русские буквы
            'а' => b'a', // Выглядит идентично латинской a
            'б' => self
                .load_custom_char([0x03, 0x04, 0x08, 0x0e, 0x11, 0x11, 0x0e, 0x00])
                .unwrap_or(b'6'),
            'в' => self
                .load_custom_char([0x00, 0x00, 0x1e, 0x11, 0x1e, 0x11, 0x1e, 0x00])
                .unwrap_or(b'b'),
            'г' => self
                .load_custom_char([0x00, 0x00, 0x1f, 0x11, 0x10, 0x10, 0x10, 0x00])
                .unwrap_or(b'r'),
            'д' => self
                .load_custom_char([0x00, 0x06, 0x0a, 0x0a, 0x0a, 0x1f, 0x11, 0x00])
                .unwrap_or(b'd'),
            'е' => b'e', // Выглядит идентично латинской e
            'ж' => self
                .load_custom_char([0x00, 0x00, 0x15, 0x0e, 0x04, 0x0e, 0x15, 0x00])
                .unwrap_or(b'x'),
            'з' => self
                .load_custom_char([0x00, 0x00, 0x0e, 0x11, 0x02, 0x11, 0x0e, 0x00])
                .unwrap_or(b'3'),
            'и' => self
                .load_custom_char([0x00, 0x00, 0x11, 0x11, 0x13, 0x15, 0x19, 0x00])
                .unwrap_or(b'u'),
            'й' => self
                .load_custom_char([0x0a, 0x00, 0x11, 0x11, 0x13, 0x15, 0x19, 0x00])
                .unwrap_or(b'u'),
            'к' => self
                .load_custom_char([0x00, 0x00, 0x11, 0x12, 0x1c, 0x12, 0x11, 0x00])
                .unwrap_or(b'k'),
            'л' => self
                .load_custom_char([0x00, 0x00, 0x0f, 0x09, 0x09, 0x09, 0x11, 0x00])
                .unwrap_or(b'n'),
            'м' => self
                .load_custom_char([0x00, 0x00, 0x11, 0x1b, 0x1b, 0x15, 0x11, 0x00])
                .unwrap_or(b'm'),
            'н' => self
                .load_custom_char([0x00, 0x00, 0x11, 0x11, 0x1f, 0x11, 0x11, 0x00])
                .unwrap_or(b'h'),
            'о' => b'o', // Выглядит идентично латинской o
            'п' => self
                .load_custom_char([0x00, 0x00, 0x1f, 0x11, 0x11, 0x11, 0x11, 0x00])
                .unwrap_or(b'n'),
            'р' => b'p', // Выглядит похоже на латинскую p
            'с' => b'c', // Выглядит идентично латинской c
            'т' => self
                .load_custom_char([0x00, 0x00, 0x1f, 0x04, 0x04, 0x04, 0x04, 0x00])
                .unwrap_or(b't'),
            'у' => b'y', // Выглядит похоже на латинскую y
            'ф' => self
                .load_custom_char([0x04, 0x04, 0x0e, 0x15, 0x15, 0x0e, 0x04, 0x04])
                .unwrap_or(b'f'),
            'х' => b'x', // Выглядит идентично латинской x
            'ц' => self
                .load_custom_char([0x00, 0x00, 0x11, 0x11, 0x11, 0x1f, 0x1f, 0x01])
                .unwrap_or(b'u'),
            'ч' => self
                .load_custom_char([0x00, 0x00, 0x11, 0x11, 0x0f, 0x01, 0x01, 0x00])
                .unwrap_or(b'4'),
            'ш' => self
                .load_custom_char([0x00, 0x00, 0x15, 0x15, 0x15, 0x15, 0x1f, 0x00])
                .unwrap_or(b'w'),
            'щ' => self
                .load_custom_char([0x00, 0x00, 0x15, 0x15, 0x15, 0x1f, 0x1f, 0x01])
                .unwrap_or(b'w'),
            'ъ' => self
                .load_custom_char([0x00, 0x00, 0x1c, 0x04, 0x0e, 0x05, 0x0e, 0x00])
                .unwrap_or(b'b'),
            'ы' => self
                .load_custom_char([0x00, 0x00, 0x11, 0x11, 0x1f, 0x19, 0x1f, 0x00])
                .unwrap_or(b'b'),
            'ь' => self
                .load_custom_char([0x00, 0x00, 0x10, 0x10, 0x1e, 0x11, 0x1e, 0x00])
                .unwrap_or(b'b'),
            'э' => self
                .load_custom_char([0x00, 0x00, 0x0e, 0x11, 0x07, 0x11, 0x0e, 0x00])
                .unwrap_or(b'e'),
            'ю' => self
                .load_custom_char([0x00, 0x00, 0x12, 0x15, 0x1d, 0x15, 0x12, 0x00])
                .unwrap_or(b'u'),
            'я' => self
                .load_custom_char([0x00, 0x00, 0x0f, 0x11, 0x0f, 0x09, 0x11, 0x00])
                .unwrap_or(b'r'),
            // Дополнительные символы
            'ё' => self
                .load_custom_char([0x0a, 0x00, 0x0e, 0x11, 0x1f, 0x10, 0x0e, 0x00])
                .unwrap_or(b'e'),
            'Ё' => self
                .load_custom_char([0x0a, 0x00, 0x0e, 0x11, 0x1f, 0x10, 0x0e, 0x00])
                .unwrap_or(b'E'),
            // Пропускаем ASCII символы как есть
            c if c.is_ascii() => c as u8,
            // Неизвестные символы
            _ => b'?',
        }
    }
}

impl core::fmt::Write for Lcd {
    fn write_str(&mut self, s: &str) -> core::fmt::Result {
        // Пишем посимвольно для надежности
        for c in s.chars() {
            let ascii = self.convert_char(c);
            // Пишем один символ
            self.lcd.write(ascii);
            
            // Обновляем позицию курсора
            self.cursor_col += 1;
            if self.cursor_col >= 16 { // 16x2 LCD
                self.cursor_col = 0;
                self.cursor_row = (self.cursor_row + 1) % 2;
            }
        }
        
        Ok(())
    }
}
